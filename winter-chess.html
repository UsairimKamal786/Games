
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Winter Chess - Player vs AI</title>
<style>
body {
  background: #0a1f3c; 
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  font-family: system-ui;
}
#turnIndicator {
  margin-bottom: 10px;
  font-size: 24px;
  color: #e0f7fa; 
  text-shadow: 0 0 8px #b2ebf2;
}
.board {
  display: grid;
  grid-template-columns: repeat(8, 80px);
  grid-template-rows: repeat(8, 80px);
  border: 6px solid #81d4fa;
  box-shadow: 0 0 20px #b3e5fc inset;
}
.square {
  width: 80px;
  height: 80px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  user-select: none;
  font-size: 48px;
  transition: all 0.2s;
}
.white { background: #e0f7fa; }
.black { background: #81d4fa; }
.selected { outline: 4px solid #80deea; box-shadow: 0 0 12px #80deea; }
.player-piece { color: #00f0ff; } 
.ai-piece { color: #000000; } 
</style>
</head>
<body>

<div id="turnIndicator">Turn: Blue Ice</div>
<div class="board" id="board"></div>

<script>
const board = document.getElementById("board");
const turnIndicator = document.getElementById("turnIndicator");

const pieces = {
  r: "‚ôú", n: "‚ôû", b: "‚ôù", q: "‚ôõ", k: "‚ôö", p: "‚ôü",
  R: "‚ôñ", N: "‚ôò", B: "‚ôó", Q: "‚ôï", K: "‚ôî", P: "‚ôô"
};

let selected = null;
let turn = "player";

let position = [
  "rnbqkbnr",
  "pppppppp",
  "........",
  "........",
  "........",
  "........",
  "PPPPPPPP",
  "RNBQKBNR"
];

function isPlayer(p) { return p === p.toUpperCase(); }
function isAI(p) { return p === p.toLowerCase(); }

function drawBoard() {
  board.innerHTML = "";
  turnIndicator.textContent = "Turn: " + (turn==="player" ? "Blue Ice" : "Black Enemy");
  for (let r=0;r<8;r++){
    for (let c=0;c<8;c++){
      const sq=document.createElement("div");
      sq.className="square "+((r+c)%2 ? "black":"white");
      const piece=position[r][c];
      sq.textContent=piece!=="."?pieces[piece]:"";
      if(piece!=="." && isPlayer(piece)) sq.classList.add("player-piece");
      if(piece!=="." && isAI(piece)) sq.classList.add("ai-piece");
      if(selected && selected.r===r && selected.c===c) sq.classList.add("selected");
      sq.onclick=()=>clickSquare(r,c);
      board.appendChild(sq);
    }
  }
}

function clickSquare(r,c){
  const piece=position[r][c];
  if(selected){
    if(isLegalMove(selected.r,selected.c,r,c)){
      movePiece(selected.r,selected.c,r,c);
      selected=null;
      if(turn==="player") turn="ai";
      drawBoard();
      if(turn==="ai") setTimeout(aiMove,300);
      return;
    } else {
      selected=null;
      drawBoard();
    }
  }
  if(piece===".") return;
  if(turn==="player" && !isPlayer(piece)) return;
  if(turn==="ai" && !isAI(piece)) return;
  selected={r,c};
  drawBoard();
}

function isLegalMove(r1,c1,r2,c2){
  const piece=position[r1][c1];
  const target=position[r2][c2];
  const dr=r2-r1, dc=c2-c1;
  if(target!=="." && (isPlayer(piece)===isPlayer(target))) return false;

  switch(piece.toLowerCase()){
    case 'p':
      if(isPlayer(piece)){
        if(dc===0 && dr===-1 && target===".") return true;
        if(dc===0 && dr===-2 && r1===6 && position[5][c1]==="." && target===".") return true;
        if(Math.abs(dc)===1 && dr===-1 && target!=="." ) return true;
      } else {
        if(dc===0 && dr===1 && target===".") return true;
        if(dc===0 && dr===2 && r1===1 && position[2][c1]==="." && target===".") return true;
        if(Math.abs(dc)===1 && dr===1 && target!=="." ) return true;
      }
      return false;
    case 'r': return (dr===0||dc===0) && clearPath(r1,c1,r2,c2);
    case 'n': return (Math.abs(dr)===2&&Math.abs(dc)===1)||(Math.abs(dr)===1&&Math.abs(dc)===2);
    case 'b': return Math.abs(dr)===Math.abs(dc) && clearPath(r1,c1,r2,c2);
    case 'q': return ((dr===0||dc===0)||Math.abs(dr)===Math.abs(dc)) && clearPath(r1,c1,r2,c2);
    case 'k': return Math.abs(dr)<=1 && Math.abs(dc)<=1;
  }
  return false;
}

function clearPath(r1,c1,r2,c2){
  const stepR=Math.sign(r2-r1);
  const stepC=Math.sign(c2-c1);
  let r=r1+stepR, c=c1+stepC;
  while(r!==r2||c!==c2){
    if(position[r][c]!=="") return false;
    if(r!==r2) r+=stepR;
    if(c!==c2) c+=stepC;
  }
  return true;
}

function movePiece(r1,c1,r2,c2){
  let row1=position[r1].split("");
  let row2=position[r2].split("");
  let piece=row1[c1];
  row2[c2]=piece;
  row1[c1]=".";
  if(piece==="P" && r2===0) row2[c2]="Q";
  if(piece==="p" && r2===7) row2[c2]="q";
  position[r1]=row1.join("");
  position[r2]=row2.join("");
  checkWin();
}

function checkWin(){
  const flat=position.join("");
  if(!flat.includes("k")){ alert("‚ùÑÔ∏è YOU WIN! Enemy King captured ‚ùÑÔ∏è"); resetGame(); return true;}
  if(!flat.includes("K")){ alert("üíÄ YOU LOST! Your King captured üíÄ"); resetGame(); return true;}
  return false;
}

function resetGame(){
  position=[
    "rnbqkbnr",
    "pppppppp",
    "........",
    "........",
    "........",
    "........",
    "PPPPPPPP",
    "RNBQKBNR"
  ];
  turn="player";
  selected=null;
  drawBoard();
}

function aiMove(){
  let moves=[];
  let captureMoves=[];
  // generate all moves
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      let piece=position[r][c];
      if(piece!=="" && isAI(piece)){
        for(let r2=0;r2<8;r2++){
          for(let c2=0;c2<8;c2++){
            if(isLegalMove(r,c,r2,c2)){
              moves.push({r,c,r2,c2});
              if(isPlayer(position[r2][c2])) captureMoves.push({r,c,r2,c2});
            }
          }
        }
      }
    }
  }
  let move;
  if(captureMoves.length>0){
    move=captureMoves[Math.floor(Math.random()*captureMoves.length)];
  } else if(moves.length>0){
    move=moves[Math.floor(Math.random()*moves.length)];
  } else return;

  // Basic King protection: if King can be captured next turn, block if possible
  // (simple heuristic: pick capture move first, otherwise random)
  movePiece(move.r,move.c,move.r2,move.c2);
  turn="player";
  drawBoard();
}

drawBoard();
</script>
</body>
</html>
